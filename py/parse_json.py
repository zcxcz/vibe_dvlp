#!/usr/bin/env python3
"""
File: parse_json.py
Description: Parse openISP.json and extract register configurations for isp_pipeline.py
             with randomization of initial values based on min and max constraints
Author: Generated by AI Assistant
"""

import json
import random
import os
from pathlib import Path

class RegisterParser:
    def __init__(self, json_path):
        """Initialize parser with path to JSON configuration file"""
        self.json_path = json_path
        self.config_data = None
        self.register_info = {}
        self.image_info = {}
        self.output_info = {}

    def parse_json(self):
        """Parse the JSON configuration file"""
        try:
            with open(self.json_path, 'r') as f:
                self.config_data = json.load(f)

            # Extract different sections
            if 'register_info' in self.config_data:
                self.register_info = self.config_data['register_info']

            if 'image_info' in self.config_data:
                self.image_info = self.config_data['image_info']

            if 'output_info' in self.config_data:
                self.output_info = self.config_data['output_info']

            return True
        except Exception as e:
            print(f"Error parsing JSON file: {e}")
            return False

    def randomize_registers(self):
        """Randomize register initial values based on min and max constraints"""
        if not self.register_info:
            print("No register information available to randomize")
            return False

        randomized_registers = {}

        for reg_name, reg_data in self.register_info.items():
            try:
                # Get min and max values
                min_val = reg_data.get('reg_value_min', 0)
                max_val = reg_data.get('reg_value_max', 1023)
                initial_values = reg_data.get('reg_initial_value', [0])
                
                # Create randomized values
                randomized_values = []
                for val in initial_values:
                    # Generate a random value within the min-max range
                    random_val = random.randint(min_val, max_val)
                    randomized_values.append(random_val)
                
                # Create a new dictionary with randomized values
                randomized_reg = reg_data.copy()
                randomized_reg['reg_initial_value'] = randomized_values
                randomized_registers[reg_name] = randomized_reg

            except Exception as e:
                print(f"Error randomizing register {reg_name}: {e}")
                # Use original values if randomization fails
                randomized_registers[reg_name] = reg_data
        
        self.register_info = randomized_registers
        return True
    
    def generate_pipeline_config_py(self):
        """Generate Python configuration module suitable for isp_pipeline.py"""
        if not self.register_info:
            print("No register information available")
            return None
        
        # Generate Python code with register variables
        code_lines = [
            "#!/usr/bin/env python3",
            '"""Generated by parse_json.py - Register configuration for isp_pipeline.py"""',
            ""
        ]
        
        # Add imports
        code_lines.append("import numpy as np")
        code_lines.append("")
        
        # Add image info
        code_lines.append("# Image Info")
        if 'image_width' in self.image_info and 'image_height' in self.image_info:
            code_lines.append(f"raw_w = {self.image_info['image_width']}")
            code_lines.append(f"raw_h = {self.image_info['image_height']}")
        code_lines.append("")
        
        # Add register variables
        code_lines.append("# Register Configurations")
        for reg_name, reg_data in self.register_info.items():
            # Convert register name from JSON format to Python variable format
            # Remove 'reg_' prefix and use snake_case
            var_name = reg_name.replace('reg_', '')
            
            # Get the value(s)
            values = reg_data.get('reg_initial_value', [0])
            
            if len(values) == 1:
                # Single value
                code_lines.append(f"{var_name} = {values[0]}")
            else:
                # Array of values - convert to numpy array or list
                value_str = ', '.join(map(str, values))
                code_lines.append(f"{var_name} = [{value_str}]")
        
        code_lines.append("")
        
        # Add CCM matrix initialization if present
        if 'reg_ccm' in self.register_info:
            ccm_values = self.register_info['reg_ccm']['reg_initial_value']
            if len(ccm_values) >= 12:
                code_lines.append("# CCM Matrix")
                code_lines.append("ccm = np.zeros((3, 4), dtype=int)")
                code_lines.append(f"ccm[0][0] = {ccm_values[0]}")
                code_lines.append(f"ccm[0][1] = {ccm_values[1]}")
                code_lines.append(f"ccm[0][2] = {ccm_values[2]}")
                code_lines.append(f"ccm[0][3] = {ccm_values[3]}")
                code_lines.append(f"ccm[1][0] = {ccm_values[4]}")
                code_lines.append(f"ccm[1][1] = {ccm_values[5]}")
                code_lines.append(f"ccm[1][2] = {ccm_values[6]}")
                code_lines.append(f"ccm[1][3] = {ccm_values[7]}")
                code_lines.append(f"ccm[2][0] = {ccm_values[8]}")
                code_lines.append(f"ccm[2][1] = {ccm_values[9]}")
                code_lines.append(f"ccm[2][2] = {ccm_values[10]}")
                code_lines.append(f"ccm[2][3] = {ccm_values[11]}")
                code_lines.append("")
        
        # Add CSC matrix initialization if present
        if 'reg_csc' in self.register_info:
            csc_values = self.register_info['reg_csc']['reg_initial_value']
            if len(csc_values) >= 12:
                code_lines.append("# CSC Matrix")
                code_lines.append("csc = np.zeros((3, 4), dtype=float)")
                code_lines.append(f"csc[0][0] = 1024 * {csc_values[0]}")
                code_lines.append(f"csc[0][1] = 1024 * {csc_values[1]}")
                code_lines.append(f"csc[0][2] = 1024 * {csc_values[2]}")
                code_lines.append(f"csc[0][3] = 1024 * {csc_values[3]}")
                code_lines.append(f"csc[1][0] = 1024 * {csc_values[4]}")
                code_lines.append(f"csc[1][1] = 1024 * {csc_values[5]}")
                code_lines.append(f"csc[1][2] = 1024 * {csc_values[6]}")
                code_lines.append(f"csc[1][3] = 1024 * {csc_values[7]}")
                code_lines.append(f"csc[2][0] = 1024 * {csc_values[8]}")
                code_lines.append(f"csc[2][1] = 1024 * {csc_values[9]}")
                code_lines.append(f"csc[2][2] = 1024 * {csc_values[10]}")
                code_lines.append(f"csc[2][3] = 1024 * {csc_values[11]}")
                code_lines.append("")
        
        # Add edge filter initialization if present
        if 'reg_edge_filter' in self.register_info:
            edge_values = self.register_info['reg_edge_filter']['reg_initial_value']
            if len(edge_values) >= 15:
                code_lines.append("# Edge Filter")
                code_lines.append("edge_filter = np.zeros((3, 5), dtype=int)")
                for i in range(3):
                    for j in range(5):
                        idx = i * 5 + j
                        if idx < len(edge_values):
                            code_lines.append(f"edge_filter[{i}][{j}] = {edge_values[idx]}")
                code_lines.append("")
        
        # Add BNF parameters if present
        code_lines.append("# BNF Parameters")
        code_lines.append("bnf_dw = np.zeros((3, 5), dtype=int)")
        code_lines.append("bnf_rw = np.zeros(4, dtype=int)")
        code_lines.append("bnf_rthres = np.zeros(3, dtype=int)")
        code_lines.append("")
        
        # Add EE parameters if present
        code_lines.append("# EE Parameters")
        code_lines.append("ee_gain = np.zeros(2, dtype=int)")
        code_lines.append("ee_thres = np.zeros(2, dtype=int)")
        code_lines.append("ee_emclip = np.zeros(2, dtype=int)")
        code_lines.append("")
        
        # Add FCS parameters if present
        code_lines.append("# FCS Parameters")
        code_lines.append("fcs_edge = np.zeros(2, dtype=int)")
        code_lines.append("")

        return '\n'.join(code_lines)

    def save_pipeline_config_py(self, output_path):
        """Save the generated Python configuration module"""
        config_code = self.generate_pipeline_config_py()
        if not config_code:
            return False

        try:
            # Ensure the directory exists
            os.makedirs(os.path.dirname(output_path), exist_ok=True)

            with open(output_path, 'w') as f:
                f.write(config_code)

            # Make the file executable
            os.chmod(output_path, 0o755)

            print(f"Python configuration module saved to {output_path}")
            return True
        except Exception as e:
            print(f"Error saving Python configuration module: {e}")
            return False

    def print_registers_summary(self):
        """Print a summary of the registers"""
        if not self.register_info:
            print("No register information available")
            return

        print("\nRegister Configuration Summary:")
        print("=" * 80)
        print(f"{'Register Name':<30} {'Bit Width':<10} {'Value':<20} {'Range':<20}")
        print("-" * 80)

        for reg_name, reg_data in self.register_info.items():
            bit_width = reg_data.get('reg_bit_width', 0)
            values = reg_data.get('reg_initial_value', [])
            min_val = reg_data.get('reg_value_min', 0)
            max_val = reg_data.get('reg_value_max', 0)

            # Format values for display
            if len(values) == 1:
                value_str = str(values[0])
            else:
                value_str = f"[{' '.join(map(str, values))}]"

            # Truncate long values for display
            if len(value_str) > 18:
                value_str = value_str[:15] + "..."

            range_str = f"{min_val} - {max_val}"

            print(f"{reg_name:<30} {bit_width:<10} {value_str:<20} {range_str:<20}")

        print("=" * 80)


def main():
    # Define paths
    current_dir = Path(__file__).parent.resolve()
    project_root = current_dir.parent  # /home/sheldon/hls_project/vibe_crop
    json_path = os.path.join(project_root, 'src', 'openISP.json')
    output_path = os.path.join(current_dir, 'openISP', 'isp_pipeline_config.py')
    
    # Create parser instance
    parser = RegisterParser(json_path)
    
    # Parse and process the JSON
    if parser.parse_json():
        print(f"Successfully parsed {json_path}")
        
        # Randomize registers
        if parser.randomize_registers():
            print("Successfully randomized register values")
            
            # Print summary
            parser.print_registers_summary()
            
            # Save Python configuration module
            parser.save_pipeline_config_py(output_path)
    else:
        print("Failed to parse JSON file")


if __name__ == "__main__":
    main()